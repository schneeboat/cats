Initialization:

Assume the original image A is of size n*n, that can be cut into m square patches that have identical size of t*t  
OR say (n/sqrt(m) * n/sqrt(m))

img[1]

Now, in the place of the right and the bottom, add a brim of 1 pixel in width:

img[2]

Then, the modified image B is of size (n+1)*(n+1), that can still be cut into m square patches that have identical size of (t+1)*(t+1) 
OR say ((n+1)/sqrt(m)*(n+1)/sqrt(m)), 
However, they way of cutting is different, we introduce an overlapping of 1 pixel between any 2 patches. 
Take the following example with m=16:

img[3]

In this way of cutting, we are sure that, for instance, the right edge of patch 1 is identical to the left edge of patch 2

img[4]

Note that the top-left patch is already in the right place, hence, the queue consists of m-1 remaining patches

img[5]

For each patch, the following values are stored:

img[6]

-every pixel value in the left edge
-every pixel value in the right edge
-every pixel value in the top edge
-every pixel value in the bottom edge


Minor differences between RGB and Grayscale


Algorithm:

first populate all  on the left side of the image by comparing edge 4 against edge 2

img[7]

loop through remaining patches
	compare edge 4 against edge 2
		if edges match, 'glue' the overlapping edge together  (vertically)
		
		
for the	rest, it is enough to compare edge 1 against edge 3	

loop through remaining patches
	compare edge 3 against edge 1
		if edges match, 'glue the overlapping edge together (horizentally)
		

continue until it exhausts all the patches.

At the very end, remove the added brim, the image is now restored.

img[8]


